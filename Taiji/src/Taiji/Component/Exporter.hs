-- Export results generated by Taiji for visualization by external programs.
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
module Taiji.Component.Exporter (builder) where

import           Bio.Data.Experiment.Types
import           Bio.Utils.Misc            (readDouble)
import           Control.Lens              ((.=), (^.))
import           Control.Monad
import           Control.Monad.IO.Class    (liftIO)
import           Data.Binary               (encode)
import qualified Data.ByteString.Char8     as B
import qualified Data.ByteString.Lazy     as BL
import           Data.CaseInsensitive      as CI (CI, mk, original)
import           Data.Char                 (toLower, toUpper)
import           Data.Function             (on)
import           Data.List                 (groupBy, sort)
import qualified Data.Map.Strict           as M
import           Data.Maybe
import qualified Data.Text                 as T
import           IGraph                    (getNodes, nodeLab, pre, suc)
import           Scientific.Workflow
import           Shelly                    (run_, shelly)
import           System.IO.Temp            (withTempDirectory)
import Control.DeepSeq (($!!))
import Codec.Compression.GZip (compressWith, defaultCompressParams, compressLevel, bestCompression)

import           Taiji.Component.Rank      (buildNet)
import           Taiji.Types

builder :: Builder ()
builder = do
    node "Export_results" [| \x -> do
        output <- getConfig' "outputDir"
        liftIO $ getResults (output ++ "/TaijiResults.bin.gz") x
        |] $ do
            submitToRemote .= Just False
            stateful .= True
            note .= "Export results."
    ["Output_ranks", "Output_expression","Link_TF_gene"] ~> "Export_results"

getResults :: Experiment e
           => FilePath
           -> ( FilePath    -- ^ File storing the PageRank results
              , Maybe FilePath    -- ^ Gene expression
              , [e]     -- ^ networks
              )
           -> IO ()
getResults output (pagerank, Just expr, es) = do
    table <- readData pagerank expr
    nets <- forM es $ \e -> do
        gr <- buildNet e
        let results = M.fromList $ flip mapMaybe (rowNames table) $
                \x -> case getNodes gr (mk x) of
                    [] -> Nothing
                    (i:_) ->
                        let children = B.intercalate "\t" $
                                map (format . original . nodeLab gr) $ pre gr i
                            parents = B.intercalate "\t" $
                                map (format . original . nodeLab gr) $ suc gr i
                        in Just (x, parents `B.append` "+" `B.append` children)
        return $!! (fromJust $ e^.groupName, results)
    BL.writeFile output $
        compressWith defaultCompressParams{compressLevel=bestCompression} $
        encode $ TaijiResults table $ M.fromList nets
  where
    format x = let (a, b) = B.splitAt 1 x
               in B.map toUpper a `B.append` B.map toLower b

-- | Read data, normalize and calculate p-values.
readData :: FilePath   -- ^ PageRank
         -> FilePath   -- ^ Gene expression
         -> IO RankTable
readData input1 input2 = do
    rank <- readTSV <$> B.readFile input1
    expr <- (fmap log' . readTSV) <$> B.readFile input2
    let (labels, xs) = unzip $ map unzip $ groupBy ((==) `on` (fst.fst)) $ sort $
            M.toList $ M.intersectionWith (,) rank expr
        rowlab = map (format . original) $ fst $ unzip $ map head labels
        collab = map original $ snd $ unzip $ head $ labels
    return $ uncurry (RankTable rowlab collab) $ unzip $ map unzip xs
  where
    log' x | x == 0 = log 0.01
           | otherwise = log x
    format x = let (a, b) = B.splitAt 1 x
               in B.map toUpper a `B.append` B.map toLower b

readTSV :: B.ByteString -> M.Map (CI B.ByteString, CI B.ByteString) Double
readTSV input = M.fromList $ concatMap (f . B.split '\t') content
  where
    f (x:xs) = zipWith (\s v -> ((mk x, mk s), readDouble v)) samples xs
    (header:content) = B.lines input
    samples = tail $ B.split '\t' header
