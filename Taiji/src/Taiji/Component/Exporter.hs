-- Export results generated by Taiji for visualization by external programs.
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
module Taiji.Component.Exporter (builder) where

import           Bio.Data.Experiment.Types
import           Bio.Utils.Misc            (readDouble)
import           Control.Lens              ((.=), (^.))
import           Control.Monad
import           Control.Monad.IO.Class    (liftIO)
import           Data.Binary               (encodeFile)
import qualified Data.ByteString.Char8     as B
import           Data.CaseInsensitive      as CI (CI, mk, original)
import           Data.Char                 (toLower, toUpper)
import           Data.Function             (on)
import           Data.List                 (groupBy, sort)
import qualified Data.Map.Strict           as M
import           Data.Maybe
import qualified Data.Text                 as T
import           Database.PureCDB          (addBS, makeCDB)
import           IGraph                    (getNodes, nodeLab, pre, suc)
import           Scientific.Workflow
import           Shelly                    (run_, shelly)
import           System.IO.Temp            (withTempDirectory)

import           Taiji.Component.Rank      (buildNet)
import           Taiji.Types

builder :: Builder ()
builder = do
    node "Export_results" [| \x -> do
        output <- getConfig' "outputDir"
        liftIO $ getResults (output ++ "/TaijiResults.zip") x
        |] $ do
            submitToRemote .= Just False
            stateful .= True
            note .= "Export results."
    ["Output_ranks", "Output_expression","Link_TF_gene"] ~> "Export_results"

getResults :: Experiment e
           => FilePath
           -> ( FilePath    -- ^ File storing the PageRank results
              , Maybe FilePath    -- ^ Gene expression
              , [e]     -- ^ networks
              )
           -> IO ()
getResults output (pagerank, Just expr, es) =
    withTempDirectory "./" "tmp_dir_results." $ \tmp -> do
        table <- readData pagerank expr
        encodeFile (tmp ++ "/ranktable") table
        forM_ es $ \e -> do
            gr <- buildNet e
            let filename = tmp ++ "/" ++ T.unpack (fromJust $ e^.groupName) ++ ".cdb"
            flip makeCDB filename $ forM_ (rowNames table) $ \x -> case getNodes gr (mk x) of
                [] -> return ()
                (i:_) -> do
                    let children = B.intercalate "\t" $ map (format . original . nodeLab gr) $ pre gr i
                        parents = B.intercalate "\t" $ map (format . original . nodeLab gr) $ suc gr i
                    addBS (x `B.append` "_parents") parents
                    addBS (x `B.append` "_children") children
        shelly $ run_ "zip" ["-rj", T.pack output, T.pack tmp]
  where
    format x = let (a, b) = B.splitAt 1 x
               in B.map toUpper a `B.append` B.map toLower b

-- | Read data, normalize and calculate p-values.
readData :: FilePath   -- ^ PageRank
         -> FilePath   -- ^ Gene expression
         -> IO RankTable
readData input1 input2 = do
    rank <- readTSV <$> B.readFile input1
    expr <- (fmap log' . readTSV) <$> B.readFile input2
    let (labels, xs) = unzip $ map unzip $ groupBy ((==) `on` (fst.fst)) $ sort $
            M.toList $ M.intersectionWith (,) rank expr
        rowlab = map (format . original) $ fst $ unzip $ map head labels
        collab = map (format . original) $ snd $ unzip $ head $ labels
    return $ uncurry (RankTable rowlab collab) $ unzip $ map unzip xs
  where
    log' x | x == 0 = log 0.01
           | otherwise = log x
    format x = let (a, b) = B.splitAt 1 x
               in B.map toUpper a `B.append` B.map toLower b

readTSV :: B.ByteString -> M.Map (CI B.ByteString, CI B.ByteString) Double
readTSV input = M.fromList $ concatMap (f . B.split '\t') content
  where
    f (x:xs) = zipWith (\s v -> ((mk x, mk s), readDouble v)) samples xs
    (header:content) = B.lines input
    samples = tail $ B.split '\t' header
